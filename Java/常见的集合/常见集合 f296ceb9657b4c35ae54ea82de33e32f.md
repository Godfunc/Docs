# 常见集合

## ArrayList

**实现：**底层实现是 `Object` 类型的数组

**初始化：**默认创建对象底层数组是空数组，在第一次添加元素时会将数组容量扩容为10

**扩容：**以后每次扩容为原来的(大约)1.5倍`(newCapacity = oldCapacity + (oldCapacity >> 1))`

**优缺点：**查询快，插入慢。因为插入元素可能涉及到数组的扩容和元素的位移

**最大容量：**`Integer.MAX_VALUE`，为了防止OOM，应该尽量让数组大小控制在 `Integer.MAX_VALUE-8`。

**其他：**`subList` 方法返回的子集合和原集合使用的是同一个底层数组。

**是否线程安全：**非线程安全

## LinkedList

**实现：**底层使用的是双向链表，记录了链表的**头节点**和**尾节点**

**优缺点：**查询慢（需要遍历链表），修改快

**特点：**实现了 `Deque` 接口，可以作为一个双端队列使用，使用 `peek` 方法获取一个元素，使用 `poll` 方法获取并删除一个元素，使用 `offer` 方法添加一个元素。

**是否线程安全：**非线程安全

## Vector

**实现：**底层使用的是 `Object` 类型的数组

**初始化：**默认创建对象会将底层数组容量初始化为`10`

**扩容：**以后每次扩容为原来的 `2` 倍，也可以指定每次扩容的增长值 `capacityIncrement` 

**是否线程安全：**是线程安全的，在每个操作方法上加了 `synchronized` 

## Hashtable

**实现：**底层实现是哈希表，采用数组+链表的方式进行数据存储。

**初始化：**创建对象时会将底层数组容量初始化为 `11`，负载因子默认是 `0.75f`

**扩容：**每次扩容为原来的 `2n+1` ，每次扩容都需要对所有的key进行rehash

**特点：**链表采用头插法；key-value可以为null

**是否线程安全：**是线程安全的，在每个操作方法上加了 `synchronized` 

## HashMap

**实现：**底层实现是哈希表，采用数组+链表/红黑树进行数据存储。

**初始化：**默认创建对象底层数组是null，第一次添加数据的时候会将数组容量初始化为 `16`

**扩容：**以后每次扩容为原来的 `2` 倍。默认负载因子是 `0.75f` ，扩容时不需要对所有节点进行rehash，只需要计算节点高低位，低位保持不变，高位就在原来索引的基础上加上 `oldCap` ，得到对应的存放位置。

**转换：**当链表的长度 `>8` 并且数组长度 `≥64` ，转为红黑树；如果链表的长度 `<64` ，就进行扩容；当红黑树节点的数量 `≤6` 时，转为链表

**其他：**索引计算方式 `h^(h >>> 16)&(n-1)` ，7上8下

**是否线程安全：**非线程安全

## LinkedHashMap

**实现：**底层使用的是 `HashMap` + 链表，链表用来记录节点添加的顺序，同时记录头节点和尾节点

**是否线程安全：**非线程安全

## LinkedHashSet

继承了`HashSet`，底层使用的是 `value` 固定的 `LinkedHashMap`

## HashSet

底层使用的是一个 `value` 固定的 `HashMap`

## TreeSet

底层使用的是红黑树，使用一个比较器，对元素进行比较后插入到对应位置

## CopyOnWriteArrayList

**实现：**底层是数组

**初始化：**默认创建对象，底层数组是一个空数组

**优缺点：**适合读多写少的情况，频繁写会导致频繁进行数组拷贝。

**是否线程安全：**是线程安全的。添加元素时，会使用 `ReentrantLock` 进行加锁，将原数组拷贝到新数组中，然后将要添加的元素放入到新数组中，最后将新数组设为集合的底层数组。